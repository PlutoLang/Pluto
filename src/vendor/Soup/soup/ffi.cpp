#include "ffi.hpp"

#include <cstring> // memcpy

#if SOUP_WINDOWS
#include <windows.h>
#endif

#include "memGuard.hpp"

NAMESPACE_SOUP
{
	bool ffi::isSafeToCall(void* func) noexcept
	{
		bool ret = true;
#if SOUP_WINDOWS
		auto ntdll = LoadLibraryA("ntdll.dll");
		if (GetProcAddress(ntdll, "NtRaiseHardError") == func)
		{
			ret = false;
		}
		FreeLibrary(ntdll);
#endif
		return ret;
	}

	uintptr_t ffi::call(void* func, const uintptr_t* args, size_t nargs)
	{
		// Generated by codegen/ffi.php
		switch (nargs)
		{
		case 0: return reinterpret_cast<uintptr_t(*)()>(func)();
		case 1: return reinterpret_cast<uintptr_t(*)(uintptr_t)>(func)(args[0]);
		case 2: return reinterpret_cast<uintptr_t(*)(uintptr_t, uintptr_t)>(func)(args[0], args[1]);
		case 3: return reinterpret_cast<uintptr_t(*)(uintptr_t, uintptr_t, uintptr_t)>(func)(args[0], args[1], args[2]);
		case 4: return reinterpret_cast<uintptr_t(*)(uintptr_t, uintptr_t, uintptr_t, uintptr_t)>(func)(args[0], args[1], args[2], args[3]);
		case 5: return reinterpret_cast<uintptr_t(*)(uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t)>(func)(args[0], args[1], args[2], args[3], args[4]);
		case 6: return reinterpret_cast<uintptr_t(*)(uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t)>(func)(args[0], args[1], args[2], args[3], args[4], args[5]);
		case 7: return reinterpret_cast<uintptr_t(*)(uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t)>(func)(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
		case 8: return reinterpret_cast<uintptr_t(*)(uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t)>(func)(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7]);
		case 9: return reinterpret_cast<uintptr_t(*)(uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t)>(func)(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8]);
		case 10: return reinterpret_cast<uintptr_t(*)(uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t)>(func)(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9]);
		case 11: return reinterpret_cast<uintptr_t(*)(uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t)>(func)(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10]);
		case 12: return reinterpret_cast<uintptr_t(*)(uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t)>(func)(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11]);
		case 13: return reinterpret_cast<uintptr_t(*)(uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t)>(func)(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11], args[12]);
		case 14: return reinterpret_cast<uintptr_t(*)(uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t)>(func)(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11], args[12], args[13]);
		case 15: return reinterpret_cast<uintptr_t(*)(uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t)>(func)(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11], args[12], args[13], args[14]);
		case 16: return reinterpret_cast<uintptr_t(*)(uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t)>(func)(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11], args[12], args[13], args[14], args[15]);
		case 17: return reinterpret_cast<uintptr_t(*)(uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t)>(func)(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11], args[12], args[13], args[14], args[15], args[16]);
		case 18: return reinterpret_cast<uintptr_t(*)(uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t)>(func)(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11], args[12], args[13], args[14], args[15], args[16], args[17]);
		case 19: return reinterpret_cast<uintptr_t(*)(uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t)>(func)(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11], args[12], args[13], args[14], args[15], args[16], args[17], args[18]);
		case 20: return reinterpret_cast<uintptr_t(*)(uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t)>(func)(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11], args[12], args[13], args[14], args[15], args[16], args[17], args[18], args[19]);
		}
		SOUP_THROW(BadCall());
	}

	/* To allocate a callback, we basically need to assemble the following, replacing `0xAAAABBBBCCCCDDDDull` with `user_data` and linking in `func`:

		SOUP_EXPORT uintptr_t(*func)(uintptr_t user_data, const uintptr_t* args);

		SOUP_EXPORT __declspec(safebuffers) uintptr_t test(uintptr_t a, uintptr_t b, uintptr_t c, uintptr_t d, uintptr_t e, uintptr_t f, uintptr_t g, uintptr_t h, uintptr_t i, uintptr_t j, uintptr_t k, uintptr_t l, uintptr_t m, uintptr_t n, uintptr_t o, uintptr_t p, uintptr_t q, uintptr_t r, uintptr_t s, uintptr_t t)
		{
			const uintptr_t args[20] = { a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t };
			return func(0xAAAABBBBCCCCDDDDull, args);
		}
	*/

#if SOUP_X86 && SOUP_BITS == 64
	#if SOUP_WINDOWS
		static const uint8_t callback_bytes[] = {
			0x48, 0x81, 0xEC, 0xE8, 0x00, 0x00, 0x00,					// sub     rsp, 0E8h
			0x0F, 0x29, 0xBC, 0x24, 0xD0, 0x00, 0x00, 0x00,				// movaps  [rsp+0E8h+var_18], xmm7
			0x0F, 0x29, 0xB4, 0x24, 0xC0, 0x00, 0x00, 0x00,				// movaps  [rsp+0E8h+var_28], xmm6
			0x0F, 0x28, 0x84, 0x24, 0x80, 0x01, 0x00, 0x00,				// movaps  xmm0, [rsp+0E8h+arg_90]
			0x0F, 0x28, 0x8C, 0x24, 0x70, 0x01, 0x00, 0x00,				// movaps  xmm1, [rsp+0E8h+arg_80]
			0x0F, 0x28, 0x94, 0x24, 0x60, 0x01, 0x00, 0x00,				// movaps  xmm2, [rsp+0E8h+arg_70]
			0x0F, 0x28, 0x9C, 0x24, 0x50, 0x01, 0x00, 0x00,				// movaps  xmm3, [rsp+0E8h+arg_60]
			0x0F, 0x28, 0xA4, 0x24, 0x40, 0x01, 0x00, 0x00,				// movaps  xmm4, [rsp+0E8h+arg_50]
			0x0F, 0x28, 0xAC, 0x24, 0x30, 0x01, 0x00, 0x00,				// movaps  xmm5, [rsp+0E8h+arg_40]
			0x0F, 0x28, 0xB4, 0x24, 0x20, 0x01, 0x00, 0x00,				// movaps  xmm6, [rsp+0E8h+arg_30]
			0x0F, 0x28, 0xBC, 0x24, 0x10, 0x01, 0x00, 0x00,				// movaps  xmm7, [rsp+0E8h+arg_20]
			0x48, 0x89, 0x4C, 0x24, 0x20,								// mov     [rsp+0E8h+var_C8], rcx
			0x48, 0x89, 0x54, 0x24, 0x28,								// mov     [rsp+0E8h+var_C0], rdx
			0x4C, 0x89, 0x44, 0x24, 0x30,								// mov     [rsp+0E8h+var_B8], r8
			0x4C, 0x89, 0x4C, 0x24, 0x38,								// mov     [rsp+0E8h+var_B0], r9
			0x0F, 0x29, 0x7C, 0x24, 0x40,								// movaps  [rsp+0E8h+var_A8], xmm7
			0x0F, 0x29, 0x74, 0x24, 0x50,								// movaps  [rsp+0E8h+var_98], xmm6
			0x0F, 0x29, 0x6C, 0x24, 0x60,								// movaps  [rsp+0E8h+var_88], xmm5
			0x0F, 0x29, 0x64, 0x24, 0x70,								// movaps  [rsp+0E8h+var_78], xmm4
			0x0F, 0x29, 0x9C, 0x24, 0x80, 0x00, 0x00, 0x00,				// movaps  [rsp+0E8h+var_68], xmm3
			0x0F, 0x29, 0x94, 0x24, 0x90, 0x00, 0x00, 0x00,				// movaps  [rsp+0E8h+var_58], xmm2
			0x0F, 0x29, 0x8C, 0x24, 0xA0, 0x00, 0x00, 0x00,				// movaps  [rsp+0E8h+var_48], xmm1
			0x0F, 0x29, 0x84, 0x24, 0xB0, 0x00, 0x00, 0x00,				// movaps  [rsp+0E8h+var_38], xmm0
			0x48, 0xB9, 0, 0, 0, 0, 0, 0, 0, 0,							// mov     rcx, (8 bytes)          ; this instruction is at offset 159
			0x48, 0x8D, 0x54, 0x24, 0x20,								// lea     rdx, [rsp+0E8h+var_C8]
			0xFF, 0x15, 0x18, 0x00, 0x00, 0x00,							// call    QWORD PTR [rip+0x18]
			0x0F, 0x28, 0xB4, 0x24, 0xC0, 0x00, 0x00, 0x00,				// movaps  xmm6, [rsp+0E8h+var_28] ; 8 bytes
			0x0F, 0x28, 0xBC, 0x24, 0xD0, 0x00, 0x00, 0x00,				// movaps  xmm7, [rsp+0E8h+var_18] ; 8 bytes
			0x48, 0x81, 0xC4, 0xE8, 0x00, 0x00, 0x00,					// add     rsp, 0E8h               ; 7 bytes
			0xC3,														// retn                            ; 1 byte
			0, 0, 0, 0, 0, 0, 0, 0
		};
		static constexpr const auto callback_ud_offset = 159 + 2;
#else
		static const uint8_t callback_bytes[] = {
			/*  0 */ 0x48, 0x81, 0xEC, 0xA8, 0x00, 0x00, 0x00,			// sub    rsp,0xa8
			/*  7 */ 0x48, 0x8B, 0x84, 0x24, 0xB0, 0x00, 0x00, 0x00,	// mov    rax,QWORD PTR [rsp+0xb0]
			/* 15 */ 0x48, 0x89, 0x3C, 0x24,							// mov    QWORD PTR [rsp],rdi
			/* 19 */ 0x48, 0xBF, 0, 0, 0, 0, 0, 0, 0, 0,				// movabs rdi, (8 bytes)
			0x48, 0x89, 0x74, 0x24, 0x08, 0x48, 0x89, 0xE6, 0x48, 0x89, 0x44, 0x24, 0x30, 0x48, 0x8B, 0x84, 0x24, 0xB8, 0x00, 0x00, 0x00, 0x48, 0x89, 0x54, 0x24, 0x10, 0x48, 0x89, 0x44, 0x24, 0x38, 0x48, 0x8B, 0x84, 0x24, 0xC0, 0x00, 0x00, 0x00, 0x48, 0x89, 0x4C, 0x24, 0x18, 0x48, 0x89, 0x44, 0x24, 0x40, 0x48, 0x8B, 0x84, 0x24, 0xC8, 0x00, 0x00, 0x00, 0x4C, 0x89, 0x44, 0x24, 0x20, 0x48, 0x89, 0x44, 0x24, 0x48, 0x48, 0x8B, 0x84, 0x24, 0xD0, 0x00, 0x00, 0x00, 0x4C, 0x89, 0x4C, 0x24, 0x28, 0x48, 0x89, 0x44, 0x24, 0x50, 0x48, 0x8B, 0x84, 0x24, 0xD8, 0x00, 0x00, 0x00, 0x48, 0x89, 0x44, 0x24, 0x58, 0x48, 0x8B, 0x84, 0x24, 0xE0, 0x00, 0x00, 0x00, 0x48, 0x89, 0x44, 0x24, 0x60, 0x48, 0x8B, 0x84, 0x24, 0xE8, 0x00, 0x00, 0x00, 0x48, 0x89, 0x44, 0x24, 0x68, 0x48, 0x8B, 0x84, 0x24, 0xF0, 0x00, 0x00, 0x00, 0x48, 0x89, 0x44, 0x24, 0x70, 0x48, 0x8B, 0x84, 0x24, 0xF8, 0x00, 0x00, 0x00, 0x48, 0x89, 0x44, 0x24, 0x78, 0x48, 0x8B, 0x84, 0x24, 0x00, 0x01, 0x00, 0x00, 0x48, 0x89, 0x84, 0x24, 0x80, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x84, 0x24, 0x08, 0x01, 0x00, 0x00, 0x48, 0x89, 0x84, 0x24, 0x88, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x84, 0x24, 0x10, 0x01, 0x00, 0x00, 0x48, 0x89, 0x84, 0x24, 0x90, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x84, 0x24, 0x18, 0x01, 0x00, 0x00, 0x48, 0x89, 0x84, 0x24, 0x98, 0x00, 0x00, 0x00,
			0xFF, 0x15, 0x08, 0x00, 0x00, 0x00,							// call   QWORD PTR [rip+0x8]
			0x48, 0x81, 0xC4, 0xA8, 0x00, 0x00, 0x00,					// add    rsp,0xa8
			0xC3,														// ret
			0, 0, 0, 0, 0, 0, 0, 0
		};
		static constexpr const auto callback_ud_offset = 19 + 2;
	#endif
#else
	static const uint8_t callback_bytes[] = {};
	static constexpr const auto callback_ud_offset = 0;
#endif

	bool ffi::callbackAvailable()
	{
		return sizeof(callback_bytes) != 0;
	}

	void* ffi::callbackAlloc(uintptr_t(*func)(uintptr_t user_data, const uintptr_t* args), uintptr_t user_data)
	{
		if constexpr (sizeof(callback_bytes) != 0)
		{
			void* block = memGuard::alloc(sizeof(callback_bytes), memGuard::ACC_RWX);
			memcpy(block, callback_bytes, sizeof(callback_bytes));
			*(uintptr_t*)((uint8_t*)block + callback_ud_offset) = user_data;
			*(void**)((uint8_t*)block + sizeof(callback_bytes) - sizeof(void*)) = (void*)func;
			return block;
		}
		return nullptr;
	}

	void ffi::callbackFree(void* cb)
	{
		return memGuard::free(cb, sizeof(callback_bytes));
	}
}
