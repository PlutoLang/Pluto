#include "ffi.hpp"

#include <cstring> // memcpy

#if SOUP_WINDOWS
#include <windows.h>
#endif

#include "memGuard.hpp"

NAMESPACE_SOUP
{
	bool ffi::isSafeToCall(void* func) noexcept
	{
		bool ret = true;
#if SOUP_WINDOWS
		auto ntdll = LoadLibraryA("ntdll.dll");
		if (GetProcAddress(ntdll, "NtRaiseHardError") == func)
		{
			ret = false;
		}
		FreeLibrary(ntdll);
#endif
		return ret;
	}

	uintptr_t ffi::call(void* func, const uintptr_t* args, size_t nargs)
	{
		// Generated by codegen/ffi.php
		switch (nargs)
		{
		case 0: return reinterpret_cast<uintptr_t(*)()>(func)();
		case 1: return reinterpret_cast<uintptr_t(*)(uintptr_t)>(func)(args[0]);
		case 2: return reinterpret_cast<uintptr_t(*)(uintptr_t, uintptr_t)>(func)(args[0], args[1]);
		case 3: return reinterpret_cast<uintptr_t(*)(uintptr_t, uintptr_t, uintptr_t)>(func)(args[0], args[1], args[2]);
		case 4: return reinterpret_cast<uintptr_t(*)(uintptr_t, uintptr_t, uintptr_t, uintptr_t)>(func)(args[0], args[1], args[2], args[3]);
		case 5: return reinterpret_cast<uintptr_t(*)(uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t)>(func)(args[0], args[1], args[2], args[3], args[4]);
		case 6: return reinterpret_cast<uintptr_t(*)(uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t)>(func)(args[0], args[1], args[2], args[3], args[4], args[5]);
		case 7: return reinterpret_cast<uintptr_t(*)(uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t)>(func)(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
		case 8: return reinterpret_cast<uintptr_t(*)(uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t)>(func)(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7]);
		case 9: return reinterpret_cast<uintptr_t(*)(uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t)>(func)(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8]);
		case 10: return reinterpret_cast<uintptr_t(*)(uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t)>(func)(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9]);
		case 11: return reinterpret_cast<uintptr_t(*)(uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t)>(func)(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10]);
		case 12: return reinterpret_cast<uintptr_t(*)(uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t)>(func)(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11]);
		case 13: return reinterpret_cast<uintptr_t(*)(uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t)>(func)(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11], args[12]);
		case 14: return reinterpret_cast<uintptr_t(*)(uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t)>(func)(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11], args[12], args[13]);
		case 15: return reinterpret_cast<uintptr_t(*)(uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t)>(func)(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11], args[12], args[13], args[14]);
		case 16: return reinterpret_cast<uintptr_t(*)(uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t)>(func)(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11], args[12], args[13], args[14], args[15]);
		case 17: return reinterpret_cast<uintptr_t(*)(uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t)>(func)(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11], args[12], args[13], args[14], args[15], args[16]);
		case 18: return reinterpret_cast<uintptr_t(*)(uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t)>(func)(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11], args[12], args[13], args[14], args[15], args[16], args[17]);
		case 19: return reinterpret_cast<uintptr_t(*)(uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t)>(func)(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11], args[12], args[13], args[14], args[15], args[16], args[17], args[18]);
		case 20: return reinterpret_cast<uintptr_t(*)(uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t)>(func)(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11], args[12], args[13], args[14], args[15], args[16], args[17], args[18], args[19]);
		}
		SOUP_THROW(BadCall());
	}

#if SOUP_X86 && SOUP_BITS == 64
	struct FfiCallbackTls
	{
		uintptr_t a, b, c, d;
#if !SOUP_WINDOWS
		uintptr_t e, f;
#endif
	};

	static thread_local FfiCallbackTls ffi_callback_tls;

	static void callback_save_args(uintptr_t a, uintptr_t b, uintptr_t c, uintptr_t d
#if !SOUP_WINDOWS
		, uintptr_t e, uintptr_t f
#endif
	)
	{
		ffi_callback_tls.a = a;
		ffi_callback_tls.b = b;
		ffi_callback_tls.c = c;
		ffi_callback_tls.d = d;
#if !SOUP_WINDOWS
		ffi_callback_tls.e = e;
		ffi_callback_tls.f = f;
#endif
	}

	static uintptr_t callback_finish(uintptr_t(*func)(uintptr_t user_data, const uintptr_t* args), uintptr_t user_data, uintptr_t c, uintptr_t d, uintptr_t e, uintptr_t f, uintptr_t g, uintptr_t h, uintptr_t i, uintptr_t j, uintptr_t k, uintptr_t l, uintptr_t m, uintptr_t n, uintptr_t o, uintptr_t p, uintptr_t q, uintptr_t r, uintptr_t s, uintptr_t t)
	{
		const uintptr_t args[20] = {
			ffi_callback_tls.a,
			ffi_callback_tls.b,
			ffi_callback_tls.c,
			ffi_callback_tls.d,
#if SOUP_WINDOWS
			e,
			f,
#else
			ffi_callback_tls.e,
			ffi_callback_tls.f,
#endif
			g,
			h,
			i,
			j,
			k,
			l,
			m,
			n,
			o,
			p,
			q,
			r,
			s,
			t,
		};
		return func(user_data, args);
	}

	static const uint8_t callback_bytes[] = {
		/*  0 */ 0x48, 0x81, 0xEC, 0xA8, 0x00, 0x00, 0x00,			// sub     rsp, 0xa8
		/*  7 */ 0xFF, 0x15, (46 - 13), 0, 0, 0,					// call    QWORD PTR [rip+...] ; callback_save_args
		/* 13 */ 0x48, 0x81, 0xC4, 0xA8, 0x00, 0x00, 0x00,			// add     rsp, 0xa8
	#if SOUP_WINDOWS
		/* 20 */ 0x48, 0xB9, 0, 0, 0, 0, 0, 0, 0, 0,				// mov     rcx, (8 bytes) ; func
		/* 30 */ 0x48, 0xBA, 0, 0, 0, 0, 0, 0, 0, 0,				// mov     rdx, (8 bytes) ; user_data
	#else
		/* 20 */ 0x48, 0xBF, 0, 0, 0, 0, 0, 0, 0, 0,				// mov     rdi, (8 bytes) ; func
		/* 30 */ 0x48, 0xBE, 0, 0, 0, 0, 0, 0, 0, 0,				// mov     rsi, (8 bytes) ; user_data
	#endif
		/* 40 */ 0xFF, 0x25, 0x08, 0x00, 0x00, 0x00,				// jmp     QWORD PTR [rip+0x8] ; callback_finish
		// 46: callback_save_args
		// 54: callback_finish
	};
#endif

	void* ffi::callbackAlloc(uintptr_t(*func)(uintptr_t user_data, const uintptr_t* args), uintptr_t user_data)
	{
#if SOUP_X86 && SOUP_BITS == 64
		void* block = memGuard::alloc(sizeof(callback_bytes) + 16, memGuard::ACC_RWX);
		memcpy(block, callback_bytes, sizeof(callback_bytes));
		*(void**)((uint8_t*)block + 20 + 2) = (void*)func;
		*(uintptr_t*)((uint8_t*)block + 30 + 2) = user_data;
		*(void**)((uint8_t*)block + sizeof(callback_bytes)) = (void*)&callback_save_args;
		*(void**)((uint8_t*)block + sizeof(callback_bytes) + sizeof(void*)) = (void*)&callback_finish;
		return block;
#endif
		return nullptr;
	}

	void ffi::callbackFree(void* cb)
	{
#if SOUP_X86 && SOUP_BITS == 64
		return memGuard::free(cb, sizeof(callback_bytes));
#endif
	}
}
