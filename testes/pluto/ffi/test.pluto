local ffi = require "ffi"

local lib = ffi.open(os.platform == "windows" ? "lib" : "./liblib.so")
assert(lib:value("i32", "MY_MAGIC_INT") == 69)
assert(lib:wrap("i32", "add", "i32", "i32")(38, 4) == 42)

-- 'lib' can be used like any old table
lib.add = lib:wrap("i32", "add", "i32", "i32")
assert(lib.add(32, 10) == 42)
lib.add = nil

-- lib:cdef provides a subset of C as an alternative to the above usage
lib:cdef[[
int MY_MAGIC_INT;

int add(int a, int b);
]]
assert(lib.MY_MAGIC_INT == 69)
assert(lib.add(1, 2) == 3)

-- Structs
local Colour = ffi.struct[[
    struct Colour {
        uint8_t r;
        uint8_t g;
        uint8_t b;
    };
]]
assert(ffi.sizeof(Colour) == 3)
assert(ffi.offsetof(Colour, "r") == 0)
assert(ffi.offsetof(Colour, "g") == 1)
assert(ffi.offsetof(Colour, "b") == 2)
local colour = new Colour()
assert(ffi.sizeof(colour) == 3)
assert(ffi.offsetof(colour, "r") == 0)
assert(ffi.offsetof(colour, "g") == 1)
assert(ffi.offsetof(colour, "b") == 2)
colour.r = 255
colour.g = 0
colour.b = 127
assert(colour.r == 255)
assert(colour.g == 0)
assert(colour.b == 127)

-- ffi.cdef can be used to any number of structs which will be stored on the FFI library itself
ffi.cdef[[
struct Colour {
    uint8_t r;
    uint8_t g;
    uint8_t b;
};

struct Human {
    const char* name;
};
]]

assert(ffi.sizeof("Colour") == 3)
assert(ffi.offsetof("Colour", "r") == 0)
assert(ffi.offsetof("Colour", "g") == 1)
assert(ffi.offsetof("Colour", "b") == 2)

colour = ffi.new("Colour")
colour.r = 255
colour.g = 0
colour.b = 127
assert(colour.r == 255)
assert(colour.g == 0)
assert(colour.b == 127)

local human = ffi.new("Human")
human.name = "John"
assert(human.name == "John")
