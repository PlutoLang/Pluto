print "Welcome to the test suite."

local function assert_warn(code)
    assert(wcall(function(msg)
        local chunk, err = load(code)
        if chunk then chunk() else error(err) end
    end) ~= "")
end

local function assert_no_warn(code)
    assert(wcall(function(msg)
        local chunk, err = load(code)
        if chunk then chunk() else error(err) end
    end) == "")
end

print "Testing warnings."
do
    assert_warn([[local a; local a]]) -- var-shadow

    assert_no_warn[[
    local function takesInt(a: int) end
    takesInt(1)
    ]]
    assert_no_warn[[
    local function takesFloat(a: float) end
    takesFloat(1.0)
    ]]
    assert_no_warn[[
    local function takesNumber(a: number) end
    takesNumber(1)
    takesNumber(1.0)
    ]]
    -- void|string
    assert_no_warn[[
    local function f(): ?string
        if true then
            return
        end
        return ""
    end
    ]]
    assert_no_warn[[
    local function f(): ?string
        if true then
            return ""
        end
    end
    ]]
    -- possible void|string false-positve
    assert_no_warn[[
    local function f(): string
        if true then
        end
        return ""
    end
    ]]
    -- nil|string
    assert_no_warn[[
    local function f(): ?string
        if true then
            return ""
        end
        return nil
    end
    ]]
    assert_no_warn[[
    local function f(): ?string
        if true then
            return nil
        end
        return ""
    end
    ]]

    -- TypeHint::merge should copy over function info
    do
        local f = function(a) end
        f(1)
    end

    -- Possible exception here
    local function dummy(f: function)
        local a = f()
    end

    assert_warn([[local a = 69; local b: string = a]]) -- type mismatch in local-to-local assignment
    assert_warn([[g = 69; local l: string = g]]) -- type mismatch in global-to-local assignment

    -- type mismatch when assigning function parameter to local
    assert_warn [[
    local function f(a: int)
        local b: string = a
        print(b)
    end
    ]]

    -- 'boolean' is a valid type hint for 'boolean|dunno' function
    assert_no_warn [[local function f(): boolean
    if s then
        return true
    end
    return s[1]
end
]]

    -- 'string' is not a valid type hint for 'boolean|dunno' function
    assert_warn [[local function f(): string
    if s then
        return true
    end
    return s[1]
end
]]

    -- nullcoal stuff
    assert_warn [[local function f(): ?bool
    if x then
        return nil
    end
    return true
end
local a: string = f() ?? true]]
    assert_no_warn [[local function f(): ?bool
    if x then
        return nil
    end
    return true
end
local a: bool|int = f() ?? 0]]

    -- 'else' propagates its return type too
    assert_no_warn[[function foo(x: number): ?string
    if x == 2 then
        return nil
    else
        return "foo"
    end
end]]

    -- forstat propragates its return type too
    assert_no_warn[[local function whatever(): ?bool
    for { 1 } as v do
        return true
    end
    return nil
end]]

    -- possible false-positives after merging an unknown
    assert_no_warn[[local mt, __newindex = getmetatable(t), nil
if mt then
    __newindex = mt.__newindex
end
if __newindex then end
]]

    -- discarded-return basic test
    assert_warn[[local function f() <nodiscard>
    return 69
end

f()]]

    -- field-shadow
    assert_warn[[
    local t = {
        first = 1,
        second = 2,
        first = 3,
    }]]

    -- possible unreachable-code false-positive
    assert_no_warn[[local next
while true do
    if next then
        break
    end
    next = true
end]]
end

print "Testing assertion library."
do
    local assert = require("assert")

    local function noerror(callback, ...)
        local status, msg = pcall(callback, ...)
        assert(status == true)
    end
    local function haserror(callback, ...)
        local status, msg = pcall(callback, ...)
        assert(status == false)
    end
    local function containserror(sub, callback, ...)
        local status, msg = pcall(callback, ...)
        assert((status == false) and msg:contains(sub))
    end

    noerror(assert.isnil, nil)
    haserror(assert.isnil, 1)
    containserror("Intended Value: nil", assert.isnil, 1)
    noerror(assert.istrue, true)
    haserror(assert.istrue, 1)
    containserror("true", assert.istrue, 1)
    noerror(assert.isfalse, false)
    haserror(assert.isfalse, 1)
    containserror("false", assert.isfalse, 1)
    noerror(assert.falsy, nil)
    haserror(assert.falsy, { 1, 2, 3 })
    containserror("nil or false", assert.falsy, 99)
    noerror(assert.truthy, {})
    haserror(assert.truthy, false)
    containserror("not nil or false", assert.truthy, nil)
    noerror(assert.notnil, false)
    haserror(assert.notnil, nil)
    containserror("not nil", assert.notnil, nil)
    local fn = || -> 0
    local t1 = {
        1, 2, 3, 4, 5, 6, 7, 9, 0,
        k = {
            tabbb = {
                anothertab = {
                    1, 2, 3, 4, another_tab = {
                        ["a"] = fn
                    }
                }
            }
        }
    }
    local t2 = {
        1, 2, 3, 4, 5, 6, 7, 9, 0,
        k = {
            tabbb = {
                anothertab = {
                    1, 2, 3, 4, another_tab = {
                        ["a"] = fn
                    }
                }
            }
        }
    }
    assert.equal(t1, t2)
    noerror(assert.equal, t1, t2)
    noerror(assert.equal, t1, t1)
    haserror(assert.equal, t1, { 1, 2, 3, 4 })
    haserror(assert.nequal, t1, t2)
    noerror(assert.nequal, t1, { 1, 2, 3, k = 5 })
    noerror(assert.nequal, 1, 2)
    noerror(assert.less, 1, 2)
    containserror("<", assert.less, 2, 2)
    noerror(assert.lesseq, 2, 2)
    containserror("<=", assert.lesseq, 3, 2)
    containserror("Expression", assert.lesseq, 3, 2)
    noerror(assert.greater, 2, 1)
    containserror(">", assert.greater, 1, 2)
    noerror(assert.greatereq, 2, 2)
    containserror(">=", assert.greatereq, 2, 3)
    noerror(assert.noerror, tostring, 5)
    containserror("An error was raised:", assert.noerror, error, 5)
    noerror(assert.haserror, error, "hello world")
    containserror("Expected", assert.haserror, tostring, "hello")
    noerror(assert.searcherror, "hello world", error, "hello world")
    containserror("Expected", assert.searcherror, "hello world", tostring, "hello world")
    containserror("Absent", assert.searcherror, "hello world", error, "abc")
    assert.equal({}, {})
    assert.nequal({}, { 1 })
end

print "Testing compound assignment."
do
    local a, b = 1, 2
    a += 1
    b += 1
    assert(a == 2)
    assert(b == 3)

    a, b = 1, 2
    a -= 1
    b -= 1
    assert(a == 0)
    assert(b == 1)

    a, b = 1, 2
    a *= 2
    b *= 2
    assert(a == 2)
    assert(b == 4)

    a, b = 1, 2
    a %= 2
    b %= 2
    assert(a == 1)
    assert(b == 0)

    a, b = 1, 2
    a ^= 2
    b ^= 2
    assert(a == 1.0)
    assert(b == 4.0)

    a, b = 1, 2
    a |= 1
    b |= 1
    assert(a == 1)
    assert(b == 3)

    a, b = 1, 2
    a &= 1
    b &= 1
    assert(a == 1)
    assert(b == 0)

    a, b = 1, 2
    a /= 1
    b /= 2
    assert(a == 1.0)
    assert(b == 1.0)

    a, b = 1, 2
    a //= 1
    b //= 2
    assert(a == 1)
    assert(b == 1)

    a, b = 1, 2
    a <<= 1
    b <<= 1
    assert(a == 2)
    assert(b == 4)

    a, b = 1, 2
    a >>= 1
    b >>= 1
    assert(a == 0)
    assert(b == 1)

    a, b = 0xf0, 0x0f
    a ~= 0xff
    b ~= 0xff
    assert(a == 0x0f)
    assert(b == 0xf0)

    local t = {
        tt = {
            ttt = {
                tttt = {
                    v = 1
                }
            }
        }
    }
    t.tt.ttt.tttt.v += 499
    assert(t.tt.ttt.tttt.v == 500)
end

print "Testing string indexing."
do
    local str = "abc"
    assert(str[0] == nil)
    assert(str[1] == "a")
    assert(str[2] == "b")
    assert(str[3] == "c")
    assert(str[4] == nil)
    assert(str[5] == nil)
    assert(str[-1] == "c")
    assert(str[-2] == "b")
    assert(str[-3] == "a")
    assert(str[-4] == nil)
    assert(str[-5] == nil)
end

print "Testing continue statement."
do
    local t = { 1, 2, 3, 4, 5, 6, 7, 8, 9 }
    local sum = 0
    for index, value in ipairs(t) do
        if value == 5 then
            continue
        end
        sum += value
    end
    assert(sum == 40)

    sum = 0
    for i = 1, 10 do
        if i == 5 then
            continue
        end
        sum += i
    end
    assert(sum == 50)

    local lines = {
        "This",
        "Is",
        "Some",
        "Lines",
    }

    for index, line in ipairs(lines) do
        if index == 1 and line == "This" then
            continue
        elseif index == #lines and line == "Lines" then
            continue
        end
        assert(line != "This" and line != "Lines")
    end

    -- Upvalues should be closed
    do
        local tmp = false
        local function c()
            if tmp then
                tmp()
                return false
            end
            return 1
        end

        while c() do
            local b = 2
            ::x::
            if tmp then continue end
            tmp = ||->do b=nil end
            goto x
        end
    end
end
do
    assert(select(2, pcall(load[[--@pluto_warnings disable-all
    repeat
        continue
        local a = 1
    until a > 0]])):contains("attempt to compare number with nil"))
    assert(select(2, pcall(load[[--@pluto_warnings disable-all
    repeat
        if true then
            continue
        end
        local a = 1
    until a > 0]])):contains("attempt to compare number with nil"))
end

print "Testing table length cache."
do
    local t = {}
    for i = 1, 1000 do
        t[i] = "abc"
    end
    assert(#t == 1000, #t)

    for i = 1, 100 do
        table.remove(t, i + math.random(1, 5))
    end
    assert(#t == 900, #t)

    local metatest = setmetatable({}, { __len = function () return 5 end })
    assert(#metatest == 5, #metatest)

    t = {}
    for i = 1, 1000 do
        table.insert(t, "Hello")
        table.insert(t, "World")
    end
    assert(#t == 2000)

    t = {}
    for i = 1, 1000 do
        rawset(t, i, "Hello")
    end
    assert(#t == 1000)
end

print "Testing null coalescing operator."
do
    _G.zz = false
    z = _G.zz
    a = z
    b = "hello"
    c = a ?? b
    assert(c == false)
    _G.zz = nil
    z = _G.zz
    a = z
    b = "hello"
    c = a ?? b
    assert(c == "hello")
    local zz = false
    local z = zz
    local a = z
    local b = "hello"
    local c = a ?? b
    assert(c == false)
    zz = nil
    z = zz
    a = z
    b = "hello"
    c = a ?? b
    assert(c == "hello")
    a = false
    b = "hello"
    a ??= b
    assert(a == false)
    a = nil
    a ??= b
    assert(a == "hello")
end

print "Testing safe navigation."
do
    local a = A?.B?.C?.D
    assert(a == nil)
    a = A?["B"]?["C"]?["D"]
    assert(a == nil)
    a = A?["B"]?["C"]?["D"]?[-5]?[0]
    local T = {}
    T.K = {}
    T.K.Z = {}
    assert(T?.K?.Z == T.K.Z)

    local t = { [-1] = 1 }
    assert(t?[-1] == 1)

    local class Class
        val: bool = true

        function method()
            return self.val, 69
        end
    end
    local inst = new Class()

    local function assert_1_ret(...)
        assert(table.pack(...).n == 1)
    end

    assert(inst?:method() == true)
    assert(optinst?:method() == nil)
    assert(inst:method?() == true)
    assert(inst:optmethod?() == nil)
    assert(inst?:method?() == true)
    assert(inst?:optmethod?() == nil)
    assert(optinst?:method?() == nil)
    inst:method?()
    inst:optmethod?()
    local r1, r2 = inst:optmethod?()
    assert(r1 == nil)
    assert(r2 == nil)
    r1, r2 = optinst?:optmethod?()
    assert(r1 == nil)
    assert(r2 == nil)
    r1, r2 = inst?:optmethod?()
    assert(r1 == nil)
    assert(r2 == nil)
    assert_1_ret(inst:optmethod?())
    assert_1_ret(inst?:optmethod?())
    assert_1_ret(optinst?:optmethod?())
    inst?:method()
    inst?:optmethod?()
    optinst?:method()
    optinst?:optmethod?()
    r1, r2 = inst:method?()
    assert(r1 == true)
    assert(r2 == 69)
    r1, r2 = inst?:method?()
    assert(r1 == true)
    assert(r2 == 69)
end

print "Testing shorthand ternary."
do
    local a = 3
    -- @pluto_warnings: disable-unreachable-code
    assert((true ? "yes" : "no") == "yes")
    assert((false ? "yes" : "no") == "no")
    assert((a ? "yes" : "no") == "yes")
    assert((a == 3 ? "yes" : "no") == "yes")
    assert((a == 4 ? "yes" : "no") == "no")
    assert((3 == a ? "yes" : "no") == "yes")
    assert((4 == a ? "yes" : "no") == "no")
    assert((nil and nil) ? false : true) -- possible pitfall if we try optimizing for 'always false' conditions
    -- @pluto_warnings: enable-unreachable-code
end

print "Testing 'in' expressions."
if ("hel" in "hello") != true then error() end
if ("abc" in "hello") != false then error() end
do
    local t = {
        nil,
        key = "KEY",
        nil,
        "ARRAY"
    }
    assert("KEY" in t)
    assert("ARRAY" in t)
    assert(("NOTHING" in t) == false)
end
do
    -- table must be global for this failure case
    t = {
        subt = {
            nil,
            key = "KEY",
            nil,
            "ARRAY"
        }
    }
    assert("KEY" in t.subt)
    assert("ARRAY" in t.subt)
    local function proxy(b)
        assert(b == false)
    end
    proxy(42 in t.subt)
    t = nil
end
do
    -- temporary table
    assert("apple" in { 1, nil, "aaaa", "apple" })
    assert(not "banana" in { apple = true })
    assert(type("apple" in { apple = true }) == "boolean")
end
do -- check stack corruption
    local t = {
        nil,
        key = "KEY",
        nil,
        "ARRAY"
    }

    local a = "KEY"
    assert(a in t)
    assert(a == "KEY")
    local b = || -> "Hello World"
    local c = "ARRAY"
    assert(c in t)
    local e = "NOTHING"
    assert(not e in t)
    assert(a == "KEY")
    assert(b() == "Hello World")
    assert(c == "ARRAY")
    assert(e == "NOTHING")
end
do 
    local t = {key="value"}
    assert(("key" in t) == false)
    t[1] = "world"
    assert((1 in t) == false)
end

print "Testing break N syntax."
do
    local sum = 0
    for i = 1, 10 do
        for ii = 1, 10 do
            sum = sum + ii + i
            break 1
        end
        sum = sum + i
    end
    assert(sum == 120)
end

do
    local sum = 0
    for i = 1, 10 do
        for ii = 1, 10 do
            sum = sum + ii + i
            break 2
        end
        sum = sum + i
    end
    assert(sum == 2)
end

do
    local sum = 0
    for i = 1, 10 do
        for ii = 1, 10 do
            sum = sum + ii + i
            for iii = 1, 10 do
                sum = sum + iii + ii + i
                break 3
            end
        end
        sum = sum + i
    end
    assert(sum == 5)
end

do
    while true do
        if true then
            break
        end
    end
end

print "Testing switch statement."
do
    local value = 5
    pluto_switch (value) do
        case 5:
        break
        default:
        error()
    end
    value = 3
    pluto_switch value do
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        break
        default:
        error()
    end
    do
        local casecond <const> = 3
        pluto_switch value do
            case casecond:
            break
            default:
            error()
        end
    end
    do
        local casecond = 3
        pluto_switch value do
            case casecond:
            break
            default:
            error()
        end
    end
    do
        local casecond <const> = 3
        pluto_switch value do
            default:
            error()
            break
            case casecond:
        end
    end
    do
        local casecond = 3
        pluto_switch value do
            default:
            error()
            break
            case casecond:
        end
    end
    value = +3
    pluto_switch value do
        case +1:
        case +2:
        case +3:
        case +4:
        case +5:
        break
        default:
        error()
    end
    value = "foo"
    pluto_switch (value) do
        case "foo":
        break
        default:
        error()
    end
    pluto_switch (value) do
        case "abc":
        case "124":
        case nil:
        case false:
        case true:
        case "23420948239":
        case "foo":
        case 1238123:
        case -2409384029842:
        case "awweee":
        break
        default:
        error()
    end
    value = nil
    pluto_switch (value) do
        case -1:
        case nil:
        case -2:
        break
        default:
        error()
    end
    value = -24389
    pluto_switch (value) do
        case "aawdkawmlwadmlaw":
        case "q49324932":
        case nil:
        case "130-91230921":
        case false:
        case 231923:
        case true:
        case -234234:
        case -24389:
        case 23429:
        case "bar":
        case "foobar":
        case "barfoo":
        break
        default: 
        error()
    end
    value = -1
    pluto_switch (value) do
        case "aawdkawmlwadmlaw":
        case "q49324932":
        case nil:
        case "130-91230921":
        case false:
        case 231923:
        case true:
        case -234234:
        case -24389:
        case 23429:
        case "bar":
        case "foobar":
        case "barfoo":
        error()
    end
    value = -3.14
    pluto_switch (value) do
        case "aawdkawmlwadmlaw":
        case "q49324932":
        case nil:
        case "130-91230921":
        case false:
        case -3.14:
        case true:
        case -234234:
        case -24389:
        case 23429:
        case "bar":
        case "foobar":
        case "barfoo":
        break
    end
    value = -3.3
    pluto_switch (value) do
        case "aawdkawmlwadmlaw":
        case "q49324932":
        case nil:
        case "130-91230921":
        case false:
        case -3.15:
        case true:
        case -234234:
        case -24389:
        case 23429:
        case "bar":
        case "foobar":
        case "barfoo":
        error()
    end
    t = 0
    value = -3.15
    pluto_switch (value) do
        case "aawdkawmlwadmlaw":
        case "q49324932":
        case nil:
        case "130-91230921":
        case false:
        case -3.15:
        case true:
        case -234234:
        case -24389:
        case 23429:
        case "bar":
        case "foobar":
        case "barfoo":
        t = true
    end
    assert(t == true)
    t = 0
    value = -3.15
    pluto_switch (value) do
        case "aawdkawmlwadmlaw":
        case "q49324932":
        case nil:
        case "130-91230921":
        case false:
        case -3.15:
        case true:
        case -234234:
        case -24389:
        case 23429:
        case "bar":
        case "foobar":
        case "barfoo":
        t = true
        break
        default:
        t = false
    end
    assert(t == true)
    t = 0
    value = 3
    pluto_switch value do
        case 1:
        default:
        error()
        break
        case 3:
        t = true
    end
    assert(t == true)
    local function switchfunc(a)
        switch a do
            case 1: -- return before case
            return
            case 2:
            return 2
            case 3: -- return before defualt
            return
            default:
            return
        end
        return 3
    end
    assert(switchfunc(1) == nil)
    assert(switchfunc(2) == 2)
    assert(switchfunc(3) == nil)
end
do
    switch true do
        default:
            error()
            break
        case (87 == 87):
    end
end
do
    local x = 3
    local y = 2
    switch x do
        default:
            error()
            break
        case y + 1: -- x == y + 1
    end
end
do
    local pluto_class CloseMe
        function __construct(public closed = false)
        end

        function __close()
            self.closed = true
        end
    end
    local c = pluto_new CloseMe()
    do
        switch 1 do
            case 1:
                do
                    local _ <close> = c
                end
                break
            default:
                error()
        end
    end
    assert(c.closed)
end
do
    switch 1 do
        case 0:
            do
                local tbl = {}
            end
            break
        case 1:
            do
                local tbl = {}
                for k, v in "test string":split(" ") do
                    tbl[k] = v
                end
                assert(tbl[1] == "test")
                assert(tbl[2] == "string")
            end
            break
    end
end
do
    local function getResponse(word)
        switch word do
            case "hi", "hello":
                return "Greetings!"
            default:
                return "Unrecognised word"
            case "bye", "goodbye":
                return "Farewell!"
        end
    end
    assert(getResponse("hi") == "Greetings!")
    assert(getResponse("hello") == "Greetings!")
    assert(getResponse("bye") == "Farewell!")
    assert(getResponse("goodbye") == "Farewell!")
    assert(getResponse("deez") == "Unrecognised word")
end
do
    -- Test variable scoping
    do
        for k in pairs({}) do end
    end
    local function helper(a, b, c, d, e)
        assert(a == nil and b == nil and c == nil and d == nil and e == nil)
    end
    switch 2 do
        case 1:
            break
        case helper(switch_a, switch_b, switch_c, switch_d, switch_e):
            local switch_a, switch_b, switch_c, switch_d, switch_e
            break
    end
end
-- Continue can't be used inside of a switch statement
assert(load[[
switch 1 do
case 1:
    do
        continue
    end
    break
end]] == nil)

print "Testing switch expression."
do
    local function int2eng(i)
        return switch i do
            case 1 -> "One"
            case 2 -> "Two"
            default -> "Other"
        end
    end
    assert(int2eng(1) == "One")
    assert(int2eng(2) == "Two")
    assert(int2eng(69) == "Other")
end
do
    local function int2eng(i)
        local ret = switch i do
            case 1 -> "One"
            case 2 -> "Two"
            default -> "Other"
        end
        return ret
    end
    assert(int2eng(1) == "One")
    assert(int2eng(2) == "Two")
    assert(int2eng(69) == "Other")
end
do
    local function getResponse(word)
        return switch word do
            case "hi", "hello" -> "Greetings!"
            default -> "Unrecognised word"
            case "bye", "goodbye" -> "Farewell!"
        end
    end
    assert(getResponse("hi") == "Greetings!")
    assert(getResponse("hello") == "Greetings!")
    assert(getResponse("bye") == "Farewell!")
    assert(getResponse("goodbye") == "Farewell!")
    assert(getResponse("deez") == "Unrecognised word")
end
-- Test method call within casecond
do
    local class Human
        function __construct(public name)
        end

        function getName()
            return self.name
        end
    end
    local h = new Human("John")
    local str = switch "John" do
        case h:getName() -> "Same name"
        default -> "Different name"
    end
    assert(str == "Same name")
end
-- Test that switchexpr doesn't displace registers so we get "attempt to call a string value" or something
do
    class Human
        function __construct(public name)
        end

        function getName()
            return self.name
        end
    end
    local h = new Human("John")
    assert(switch "John" do
        case h:getName() -> "Same name"
        default -> "Different name"
    end)
end
-- Assert that default return value is nil, not whatever was in the register before
do
    function f()
        assert("dummy")
        return switch 42 do end
    end
    assert(f() == nil)
end

print "Testing table freezing."
do
    local t = table.freeze({ 1, 2, 3, "hello", "world" })
    local status, _ = pcall(function () t.key = "abc" end)
    assert(status == false, "expected error")
    status, _ = pcall(function () t["key"] = "abc" end)
    assert(status == false, "expected error")
    status, _ = pcall(function () t[1] = "abc" end)
    assert(status == false, "expected error")
    status, _ = pcall(function () t[66] = "abc" end)
    assert(status == false, "expected error")
    status, _ = pcall(function () t[function () end] = "abc" end)
    assert(status == false, "expected error")

    t = { 1, 2, 3, "hello", "world" }
    status, _ = pcall(function () t.key = "abc" end)
    assert(status == true, "unexpected error")
    status, _ = pcall(function () t["key"] = "abc" end)
    assert(status == true, "unexpected error")
    status, _ = pcall(function () t[1] = "abc" end)
    assert(status == true, "unexpected error")
    status, _ = pcall(function () t[66] = "abc" end)
    assert(status == true, "unexpected error")
    status, _ = pcall(function () t[function () end] = "abc" end)
    assert(status == true, "unexpected error")

    --[[
    table.freeze(_G)
    status, _ = pcall(function () _G.string = "abc" end)
    assert(status == false, "expected error")
    status, _ = pcall(function () _G["string"] = "abc" end)
    assert(status == false, "expected error")
    status, _ = pcall(function () _G[1] = "abc" end)
    assert(status == false, "expected error")
    status, _ = pcall(function () _G[66] = "abc" end)
    assert(status == false, "expected error")
    status, _ = pcall(function () _G[function () end] = "abc" end)
    assert(status == false, "expected error")

    table.freeze(_ENV)
    status, _ = pcall(function () _ENV.string = "abc" end)
    assert(status == false, "expected error")
    status, _ = pcall(function () _ENV["string"] = "abc" end)
    assert(status == false, "expected error")
    status, _ = pcall(function () _ENV[1] = "abc" end)
    assert(status == false, "expected error")
    status, _ = pcall(function () _ENV[66] = "abc" end)
    assert(status == false, "expected error")
    status, _ = pcall(function () _ENV[function () end] = "abc" end)
    assert(status == false, "expected error")
    --]] --> Doing this will break tests done with dofile(), since the environment is reused.
end

print "Testing pipe operator."
do
    local function f(x)
        assert(x == 69)
    end

    local a, b = {} |> dumpvar
    assert(type(a) == "string")
    assert(b == nil)

    assert(("69") |> tonumber == 69)

    -- Additional arguments shorthand (longhand would be writing a lambda)
    assert(("69") |> tonumber|16| == 0x69)

    -- Try to avoid syntax ambiguity by not allowing function call with '(' in the chain after pipe operator was used.
    ;(69) |> f (69) |> f

    -- Other types of function calls are still okay, tho, since string and table are not valid statements.
    ;("Hello") |> require"json".encode |> |x| -> assert(x == [["Hello"]])
    ;("Hello") |> (require"json".encode) |> |x| -> assert(x == [["Hello"]])

    -- Method calls
    local obj = {
        function setValue(value)
            self.value = value
        end
    }
    ;(69) |> obj:setValue
    assert(obj.value == 69)

    -- Indexing a global for argument + function
    _SERVER = {
        REDIRECT_INVOKE_FILENAME = "/deez/nuts"
    }
    assert(_SERVER.REDIRECT_INVOKE_FILENAME |> io.part|"parent"| == "/deez")
end

print "Testing standard library additions."
do
    local v3 = require"pluto:vector3"
    -- Left-handed Z-up: Thumb points left, index finger points forward, middle finger points up.
    assert(v3(1, 0, 0):torot("zl") == v3(0, 0, -90))
    assert(v3(0, 1, 0):torot("zl") == v3(0, 0, 0))
    assert(v3(0, 0, 1):torot("zl") == v3(90, 0, 0))
    -- Right-handed Z-up: Thumb points right, index finger points forward, middle finger points up.
    assert(v3(1, 0, 0):torot("zr") == v3(0, 0, 90))
    assert(v3(0, 1, 0):torot("zr") == v3(0, 0, 0))
    assert(v3(0, 0, 1):torot("zr") == v3(90, 0, 0))
    -- Left-handed Y-up: Thumb points right, index finger points up, middle finger points forward.
    assert(v3(1, 0, 0):torot("yl") == v3(0, 90, 0))
    assert(v3(0, 1, 0):torot("yl") == v3(90, 0, 0))
    assert(v3(0, 0, 1):torot("yl") == v3(0, 0, 0))
    -- Right-handed Y-up: Thumb points left, index finger points up, middle finger points forward.
    assert(v3(1, 0, 0):torot("yr") == v3(0, -90, 0))
    assert(v3(0, 1, 0):torot("yr") == v3(90, 0, 0))
    assert(v3(0, 0, 1):torot("yr") == v3(0, 0, 0))
    -- And now the inverse.
    assert(v3(0, 0, -90):todir("zl").x == 1)
    assert(v3(0, 0, 0):todir("zl").y == 1)
    assert(v3(90, 0, 0):todir("zl").z == 1)
    assert(v3(0, 0, 90):todir("zr").x == 1)
    assert(v3(0, 0, 0):todir("zr").y == 1)
    assert(v3(90, 0, 0):todir("zr").z == 1)
    assert(v3(0, 90, 0):todir("yl").x == 1)
    assert(v3(90, 0, 0):todir("yl").y == 1)
    assert(v3(0, 0, 0):todir("yl").z == 1)
    assert(v3(0, -90, 0):todir("yr").x == 1)
    assert(v3(90, 0, 0):todir("yr").y == 1)
    assert(v3(0, 0, 0):todir("yr").z == 1)
end
do
    local crypto = require("crypto")
    assert(crypto.fnv1("hello world") == 0x7DCF62CDB1910E6F)
    assert(crypto.fnv1a("hello world") == 8618312879776256743)
    assert(crypto.joaat("hello world") == 1045060183)
    -- Constexpr
    assert($crypto.fnv1("hello world") == 0x7DCF62CDB1910E6F)
    assert($crypto.fnv1a("hello world") == 8618312879776256743)
    assert($crypto.joaat("hello world") == 1045060183)

    assert(crypto.sha1("Pluto") == "bce8c9aca4120776fad6b517874aa09c46405454")
    assert(crypto.sha1("Pluto", true) == "\xbc\xe8\xc9\xac\xa4\x12\x07\x76\xfa\xd6\xb5\x17\x87\x4a\xa0\x9c\x46\x40\x54\x54")
    assert(crypto.sha256("Pluto") == "8dad5f6a7dd2dcd8c35ec2fd7babb499bcad60d27d73fe73eca2ce025dfd3b47")
    assert(crypto.sha256("Pluto", true) == "\x8d\xad\x5f\x6a\x7d\xd2\xdc\xd8\xc3\x5e\xc2\xfd\x7b\xab\xb4\x99\xbc\xad\x60\xd2\x7d\x73\xfe\x73\xec\xa2\xce\x02\x5d\xfd\x3b\x47")
    assert(crypto.sha384("Pluto", false) == "db890233a919b6745d632633c419e14540ff79f1a89bc4ac194b00e7f913f0f06d5d4d7d6cc2b4aaf9485d223afb8cf0")
    assert(crypto.sha512("Pluto", false) == "ee8410a8bf9511b94fd6669b5c3e0c4b86e8e4bf7baa8dbd2773d4d6381dd1aecebbe391bef4c6158620ab3f6b794907652d4432c2301d7e1a6caf520565cdf2")
end
do
    local base64 = require("base64")
    assert(base64.encode("Hello") == "SGVsbG8=")
    assert(base64.encode("Hello", false) == "SGVsbG8")
    assert(base64.decode("SGVsbG8") == "Hello")
    assert(base64.decode("SGVsbG8=") == "Hello")

    assert(base64.urlencode("Hello") == "SGVsbG8")
    assert(base64.urldecode("SGVsbG8") == "Hello")

    -- Binary safe
    assert(base64.encode("") == "")
    assert(base64.decode("") == "")
    assert(base64.encode("\x00") == "AA==")
    assert(base64.decode("AA==") == "\x00")
end
do
    local base32 = require("base32")

    -- Binary safe
    assert(base32.encode("") == "")
    assert(base32.decode("") == "")
    assert(base32.encode("\x00") == "AA======")
    assert(base32.decode("AA======") == "\x00")
end
do
    local json = require("json")

    assert(json.decode([[{"a":null]]).a == nil)
    assert(json.decode([[{"a":null}]], json.withnull).a == json.null)

    do
        local t = {
            __order = { "a", "b", "c" },
            a = 1,
            b = 2,
            c = 3
        }
        assert(json.encode(t) == [[{"a":1,"b":2,"c":3}]])
    end

    assert(json.encode(json.null) == "null")

    do
        local t = json.decode([[{"a":1,"b":2,"c":3}]], json.withorder)
        assert(t.__order[1] == "a")
        assert(t.__order[2] == "b")
        assert(t.__order[3] == "c")
    end
end
do
    local xml = require "pluto:xml"

    -- Decode
    assert(xml.decode([[<root non-standard-attr />]], "xml").attributes?["non-standard-attr"] == nil)
    assert(xml.decode([[<root non-standard-attr />]], "lax").attributes?["non-standard-attr"] == "")
    assert(xml.decode([[<root non-standard-attr />]], "html").attributes?["non-standard-attr"] == "")

    -- Decode: Metatable
    local root = xml.decode([[
        <root>
            <node>text</node>
        </root>
    ]])
    assert(root.node.tag == "node")
    assert(root.node.children[1] == "text")
    assert(root.node.deez == nil)

    -- Encode
    assert(xml.encode{
        tag = "root",
        children = {
            {
                tag = "entry",
                attributes = {
                    ["type"] = "primary"
                },
                children = {
                    "Text node"
                }
            },
            {
                tag = "entry"
            }
        }
    } == [[<root><entry type="primary">Text node</entry><entry></entry></root>]])
end
do
    local t = { key = "value" }
    table.insert(t, 0)
    table.insert(t, "Hello")
    table.insert(t, true)
    assert(table.contains(t, "Hello") == 2)
    assert(table.contains(t, "World") == nil)
    assert(table.contains(t, true) == 3)
    assert(table.contains(t, false) == nil)
    assert(table.contains(t, 0) == 1)
    assert(table.contains(t, 1) == nil)
    assert(table.contains(t, "value") == "key")
    assert(string.isascii("hello world") == true)
    assert(string.isascii("hello.world") == true)
    assert(string.isascii("hello1world") == true)
    assert(string.isascii("hello📙world") == false)
    assert(string.islower("hello world") == false)
    assert(string.islower("helloworld") == true)
    assert(string.islower("hello1world") == false)
    assert(string.isalpha("hello world") == false)
    assert(string.isalpha("helloworld") == true)
    assert(string.isalpha("hello1world") == false)
    assert(string.isalpha("hello?world") == false)
    assert(string.isupper("HELLOWORLD") == true)
    assert(string.isupper("HELLO WORLD") == false)
    assert(string.isupper("HELLO?WORLD") == false)
    assert(string.isalnum("abc123") == true)
    assert(string.isalnum("abc 123") == false)
    assert(string.isalnum("abc?123") == false)
    assert(string.iswhitespace("   \t   \f \n \r\n") == true)
    assert(string.iswhitespace("\t\f   \r\n \r \n \t z") == false)
    assert(string.contains("hello world", "world") == true)
    assert(string.contains("hello world", "z") == false)
    assert(string.endswith("hello world", "rld") == true)
    assert(string.endswith("hello world", "trc") == false)
    assert(string.startswith("hello world", "hello") == true)
    assert(string.startswith("hello world", "truck") == false)
    assert(string.strip("???hello world???", "?") == "hello world")
    assert(string.strip("123hello world123", "123") == "hello world")
    assert(string.lstrip("???hello world???", "?") == "hello world???")
    assert(string.lstrip("12hello world12", "12") == "hello world12")
    assert(string.rstrip("???hello world???", "?") == "???hello world")
    t = string.split("hello world abc", " ")
    assert(t[1] == "hello")
    assert(t[2] == "world")
    assert(t[3] == "abc")
    local before, after = string.partition("hello.wor.ld", ".")
    assert(before == "hello")
    assert(after == "wor.ld")
    before, after = string.partition("hello.wor.ld", ".", true)
    assert(before == "hello.wor")
    assert(after == "ld")
    assert(string.casefold("HELLO WORLD", "hello world") == true)
    assert(string.casefold("HELLO WORLD", "hello worlz") == false)
    assert(string.rfind("world hello world", "world") == 13)
    assert(string.rfind("hello x", "world") == nil)
    assert("99 dreams of 99 red balloons":rfind("%d") == 15)
    assert("aaa":rfind("%d") == nil)
    assert("1aa":rfind("%d") == 1)
    assert("a1a":rfind("%d") == 2)
    assert("aa1":rfind("%d") == 3)
    assert("111":rfind("%d") == 3)
    local _begin, _end = "aaa":rfind("")
    assert(_begin == 3 and _end == 2)
    assert("":rfind("%d") == nil)
    assert("111":rfind("%d", 1) == nil)
    assert("111":rfind("%d", 2) == 1)
    assert("111":rfind("%d", 3) == 2)
    assert("111":rfind("%d", 4) == 3)
    assert(string.upper("hello", 1) == "Hello")
    assert(string.upper("hello", 2) == "hEllo")
    assert(string.upper("hello", -1) == "hellO")
    assert(string.upper("hello", -2) == "helLo")
    assert(string.upper("hello", -6) == "hello")
    assert(string.upper("hello", 6) == "hello")
    assert(string.upper("hello") == "HELLO")
    assert(string.lower("HELLO") == "hello")
    assert(string.lower("HELLO", 1) == "hELLO")
    assert(string.lower("HELLO", 2) == "HeLLO")
    assert(string.lower("HELLO", -1) == "HELLo")
    assert(string.lower("HELLO", -2) == "HELlO")
    assert(string.lower("HELLO", -14) == "HELLO")
    assert(string.truncate("Hello, World!", 5) == "Hello")
    assert(string.truncate("Hello, World!", 5, true) == "He...")
    assert(string.truncate("Hello", 1) == "H")
    assert(string.truncate("Hello", 1, true) == "H")
    assert(string.truncate("Hello", 4, true) == "H...")
    assert(string.truncate("Hello", 6) == "Hello")
    assert(string.truncate("Hello", 6, true) == "Hello")
    assert(string.replace("hello world", "joe", "abc") == "hello world")
    assert(string.replace("hello world", " ", "") == "helloworld")
    assert(string.replace("LLLL", "L", "X") == "XXXX")
    assert(string.replace("LLLL", "L", "X", 2) == "XXLL")
    local function septest(sep)
        local fn = |...| -> string.formatint(...)

        assert(fn(100, sep) == "100")
        assert(fn(1000, sep) == $"1{sep}000")
        assert(fn(10000, sep) == $"10{sep}000")
        assert(fn(100000, sep) == $"100{sep}000")
        assert(fn(1000000, sep) == $"1{sep}000{sep}000")
        assert(fn(10000000, sep) == $"10{sep}000{sep}000")

        assert(fn(-100, sep) == "-100")
        assert(fn(-1000, sep) == $"-1{sep}000")
        assert(fn(-10000, sep) == $"-10{sep}000")
        assert(fn(-100000, sep) == $"-100{sep}000")
        assert(fn(-1000000, sep) == $"-1{sep}000{sep}000")
        assert(fn(-10000000, sep) == $"-10{sep}000{sep}000")
    end

    septest(",")
    septest(".")
    septest(" ")
    local _, err = pcall(|| -> septest("..."))
    assert(err:contains("length of 1"))

    local function septest2(sep)
        local fn = |...| -> string.formatint(...)

        assert(fn(100, sep, 2) == $"1{sep}00")
        assert(fn(1000, sep, 2) == $"10{sep}00")
        assert(fn(10000, sep, 2) == $"1{sep}00{sep}00")
        assert(fn(100000, sep, 2) == $"10{sep}00{sep}00")

        assert(fn(-100, sep, 2) == $"-1{sep}00")
        assert(fn(-1000, sep, 2) == $"-10{sep}00")
        assert(fn(-10000, sep, 2) == $"-1{sep}00{sep}00")
        assert(fn(-100000, sep, 2) == $"-10{sep}00{sep}00")
    end

    septest2(",")
    septest2(".")
    septest2(" ")

    assert(string.formatint("+3249230492345645324234234234234234234234234324242343243242342343423242344") == "+3,249,230,492,345,645,324,234,234,234,234,234,234,234,234,324,242,343,243,242,342,343,423,242,344")
    assert(string.formatint("-3249230492345645324234234234234234234234234324242343243242342343423242344") == "-3,249,230,492,345,645,324,234,234,234,234,234,234,234,234,324,242,343,243,242,342,343,423,242,344")

    local str = "Hello, World! == %% 20 <> //\\"
    local url = require"pluto:url"
    assert(url.encode(str) == "Hello%2C%20World%21%20%3D%3D%20%25%25%2020%20%3C%3E%20%2F%2F%5C")
    assert(url.decode(url.encode(str)) == str)

    local parts = require"url".parse("http://username:password@hostname:9090/path?arg=value#anchor")
    assert(parts.scheme == "http")
    assert(parts.user == "username")
    assert(parts.pass == "password")
    assert(parts.host == "hostname")
    assert(parts.port == 9090)
    assert(parts.path == "/path")
    assert(parts.query == "arg=value")
    assert(parts.fragment == "anchor")
end
do
    local t = { 5, 4, 3, 2, 1, even = 8, odd = 9 }
    table.filter(t, |v| -> v % 2 ~= 0)
    assert(t[1] == 5)
    assert(t[2] == nil)
    assert(t[3] == 3)
    assert(t[4] == nil)
    assert(t[5] == 1)
    assert(t.even == nil)
    assert(t.odd == 9)
end
do
    local t = { 5, 4, 3, 2, 1, even = 8, odd = 9 }
    table.filter(t, |k, v| -> v % 2 ~= 0, true)
    assert(t[1] == 5)
    assert(t[2] == nil)
    assert(t[3] == 3)
    assert(t[4] == nil)
    assert(t[5] == 1)
    assert(t.even == nil)
    assert(t.odd == 9)
end
do
    local t = { 5, 4, 3, 2, 1, even = 8, odd = 9 }
    table.filter(t, |k, v| -> type(k) == "string", true)
    assert(t[1] == nil)
    assert(t[2] == nil)
    assert(t[3] == nil)
    assert(t[4] == nil)
    assert(t[5] == nil)
    assert(t.even == 8)
    assert(t.odd == 9)
end
do
    do
        local t = { 1, nil, 2, nil, nil, 3, nil, nil, nil, 4, nil }
        t:reorder()
        assert(t[1] == 1)
        assert(t[2] == 2)
        assert(t[3] == 3)
        assert(t[4] == 4)
        assert(t[5] == nil)
    end

    do
        local t = { 1, 2, 3, "hello" }:reorder()
        assert(t[1] == 1)
        assert(t[2] == 2)
        assert(t[3] == 3)
        assert(t[4] == "hello")
    end
end
do
    local menu = {
        { id = 1, name = "Pizza" },
        { id = 2, name = "Doener" }
    }
    local betterDoener = { id = 2, name = "Better Doener" }
    menu = table.map(menu, |item| -> item.id == betterDoener.id ? betterDoener : item)
    assert(menu[2].name == "Better Doener")
end
do
    local t = { 1, 2, 3, key = 4 }
    t = table.map(t, |v| -> v * 2)
    assert(t[1] == 2)
    assert(t[2] == 4)
    assert(t[3] == 6)
    assert(t.key == 8)
end
do
    local t = { 1, 2, 3, key = 4 }
    t = table.map(t, |k, v| -> v * 2, true)
    assert(t[1] == 2)
    assert(t[2] == 4)
    assert(t[3] == 6)
    assert(t.key == 8)
end
do
    local t = { 1, 2, 3, key = 4 }
    t = table.map(t, |k, v| -> type(k) == "string" ? 0 : k * 2, true)
    assert(t[1] == 2)
    assert(t[2] == 4)
    assert(t[3] == 6)
    assert(t.key == 0)
end
do
    assert(0 == {1,2,}:size(true))
    assert(1 == {1,2, a = "a" }:size(true))
    assert(2 == {1,2, a = "a", b = "b" }:size(true))
    assert(3 == {1,2, a = "a", b = "b", c = "c" }:size(true))
    assert(4 == {1,2, a = "a", b = "b", c = "c", d = "d" }:size(true))
    assert(5 == {1,2, a = "a", b = "b", c = "c", d = "d", e = "e" }:size(true))

    assert(2 == {1,2,}:size(false))
    assert(3 == {1,2, a = "a" }:size(false))
    assert(4 == {1,2, a = "a", b = "b" }:size(false))
    assert(5 == {1,2, a = "a", b = "b", c = "c" }:size(false))
    assert(6 == {1,2, a = "a", b = "b", c = "c", d = "d" }:size(false))
    assert(7 == {1,2, a = "a", b = "b", c = "c", d = "d", e = "e" }:size(false))
end
do
    local t = { 1, 2, 3 }
    assert(t:reduce(|a, b| -> a + b) == 6)
    assert(t:reduce(math.max, math.mininteger) == 3)
    assert(t:reduce(math.min, math.maxinteger) == 1)
    assert({"a", "b", "c"}:reduce(|a, b| -> a .. b, "") == "abc")
end
do
    local t = { 3, 2, 1 }
    local ts = t:sorted()
    assert(t[1] == 3)
    assert(t[2] == 2)
    assert(t[3] == 1)
    assert(ts[1] == 1)
    assert(ts[2] == 2)
    assert(ts[3] == 3)
end
do
    local t = { 1, 2, 3 }
    local tm = t:mapped(|n| -> n * 2)
    assert(t[1] == 1)
    assert(t[2] == 2)
    assert(t[3] == 3)
    assert(tm[1] == 2)
    assert(tm[2] == 4)
    assert(tm[3] == 6)
end
do
    local t = { 1, 2, 3, 4, 5 }
    local tf = t:filtered(|n| -> n % 2 ~= 0)
    assert(t[1] == 1)
    assert(t[2] == 2)
    assert(t[3] == 3)
    assert(t[4] == 4)
    assert(t[5] == 5)
    assert(tf[1] == 1)
    assert(tf[2] == nil)
    assert(tf[3] == 3)
    assert(tf[4] == nil)
    assert(tf[5] == 5)
end
do
    local t = { 1, 2, 3 }
    local tr = t:reversed()
    assert(t[1] == 1)
    assert(t[2] == 2)
    assert(t[3] == 3)
    assert(tr[1] == 3)
    assert(tr[2] == 2)
    assert(tr[3] == 1)
end
do
    local t = { 1, 2, 3 }
    t[2] = nil
    local tr = t:reordered()
    assert(t[1] == 1)
    assert(t[2] == nil)
    assert(t[3] == 3)
    assert(tr[1] == 1)
    assert(tr[2] == 3)
    assert(tr[3] == nil)
end
do
    local menu = {
        { id = 1, name = "Apple" },
        { id = 2, name = "Banana" },
    }
    assert(menu:find(|item| -> item.id == 1).name == "Apple")
    assert(menu:find(|item| -> item.id == 2).name == "Banana")
    assert(menu:find(|item| -> item.id == 3) == nil)
end
do
    assert({ 1, 2, 3 }:checkall(|x| -> x % 2 == 0) == false)
    assert({ 2, 4, 6 }:checkall(|x| -> x % 2 == 0) == true)
end
do
    local t = { 1, 2, 3, "foo", "bar" }
    assert(t:size() == 5)
    t:clear()
    assert(t:size() == 0)
end
do
    assert(compareversions("0.1.0", "0.1.0") == 0)
    assert(compareversions("0.1.0", "0.2.0") ~= 0)
    assert(compareversions("0.2.0", "0.1.0") > 0)
    assert(compareversions("0.2.0", "0.1.0") >= 0)
    assert(compareversions("0.1.0", "0.2.0") < 0)
    assert(compareversions("0.1.0", "0.1.0") <= 0)
end
do
    assert(math.isnan(0 / 0) == true)
    assert(math.isnan(69) == false)
end
do
    local t = range(3)
    assert(#t == 3)
    assert(t[1] == 1)
    assert(t[2] == 2)
    assert(t[3] == 3)
end
do
    local t = range(3, 6)
    assert(#t == 4)
    assert(t[1] == 3)
    assert(t[2] == 4)
    assert(t[3] == 5)
    assert(t[4] == 6)
end
do
    local t = range(1, 10, 2)
    assert(#t == 5)
    assert(t[1] == 1)
    assert(t[2] == 3)
    assert(t[3] == 5)
    assert(t[4] == 7)
    assert(t[5] == 9)
end
do
    assert(range(10):min() == 1)
    assert(range(10):max() == 10)
end
do
    local cat = require"pluto:cat"

    local data = "List: With Value\n\tChild: With Value\n"
    local t = cat.decode(data, "flat")
    assert(t.List.__value == "With Value")
    assert(t.List.Child == "With Value")
    assert(cat.encode(t) == data)

    data = "Hello: World\n"
    t = cat.decode(data, "flat")
    assert(t.Hello == "World")
    assert(cat.encode(t) == data)

    data = "First\nSecond"
    t = cat.decode(data, "full")
    assert(t[1].name == "First")
    assert(t[2].name == "Second")

    -- Metatable
    data = "List: With Value\n\tChild: With Value\n"
    t = cat.decode(data, "full")
    assert(t.List.Child.value == "With Value")

    -- Colons in keys
    data = cat.encode({ ["Need: More"] = "Colons" })
    t = cat.decode(data, "flat")
    assert(t["Need: More"] == "Colons")

    -- __order
    assert(cat.encode({
        __order = { "Hello", "World" },
        Hello = ",",
        World = "!",
    }) == "Hello: ,\nWorld: !\n")
end
do
    local { base64, bigint, crypto } = require"*"

    local key <const> = "A Top Secret Key"
    local iv <const> = "My Top Secret IV"
    local aadata <const> = "Additional authenticated data UwU"

    assert(crypto.encrypt("Hello from Pluto", "aes-ecb", key) |> base64.encode == "v3WiSKT9g5TJfuq72QXVyg==")
    assert(crypto.encrypt("Hello, world!", "aes-ecb-pkcs7", key) |> base64.encode == "YHB7hez0jYXtaxUqLj5qRw==")
    assert(crypto.encrypt("Hello from Pluto", "aes-cbc", key, iv) |> base64.encode == "dyJWNeZQx6fjKr15cGd6Ng==")
    assert(crypto.encrypt("Hello, world!", "aes-cbc-pkcs7", key, iv) |> base64.encode == "a3bHHwmClgOnNAVFUWgwAw==")
    local enc, tag = crypto.encrypt("Hello from Pluto!", "aes-gcm", aadata, key, iv)
    assert(base64.encode(enc) == "wR/89K4T9cGKI9baKR0s7xI=")
    assert(base64.encode(tag) == "d62kzEuotTdpAgYTrzdPpQ==")

    assert(crypto.decrypt(base64.decode("v3WiSKT9g5TJfuq72QXVyg=="), "aes-ecb", key) == "Hello from Pluto")
    assert(crypto.decrypt(base64.decode("YHB7hez0jYXtaxUqLj5qRw=="), "aes-ecb-pkcs7", key) == "Hello, world!")
    assert(crypto.decrypt(base64.decode("dyJWNeZQx6fjKr15cGd6Ng=="), "aes-cbc", key, iv) == "Hello from Pluto")
    assert(crypto.decrypt(base64.decode("a3bHHwmClgOnNAVFUWgwAw=="), "aes-cbc-pkcs7", key, iv) == "Hello, world!")
    assert(crypto.decrypt(base64.decode("wR/89K4T9cGKI9baKR0s7xI="), "aes-gcm", aadata, key, iv, base64.decode("d62kzEuotTdpAgYTrzdPpQ==")) == "Hello from Pluto!")

    local priv = {
        p = bigint.new("3835446257"),
        q = bigint.new("3714629299"),
    }
    local pub = {
        n = priv.p * priv.q, -- 14247261040992083843
        e = bigint.new(0x10001),
    }

    local enc = crypto.encrypt("Hi", "rsa", pub)
    assert(base64.encode(enc) == "w1v3stxRHCs=")
    assert(crypto.decrypt(enc, "rsa", priv) == "Hi")

    enc = crypto.encrypt("Hi", "rsa", priv)
    assert(base64.encode(enc) == "GClnRNYar5c=")
    assert(crypto.decrypt(enc, "rsa", pub) == "Hi")

    priv = {
        p = bigint.new("115443384115231951475820445136871322101870729500298182134363293112660251666017"),
        q = bigint.new("98365361248415863235179644468056200977592391948608651522703704315152579004021"),
    }
    pub = {
        n = priv.p * priv.q, -- 11355630182234424425429331560518598643298965915936825610957270519615363349759012613228119611304846673085167794661819394470107090216347491908311079792054357
        e = bigint.new(0x10001),
    }

    local sig = crypto.sign("Pluto is certified cool", "rsa-sha1", priv)
    assert(crypto.verify("Pluto is certified cool", "rsa-sha1", pub, sig))
end
do
    local bigint = require "pluto:bigint"

    do
        local q, r = new bigint(10):div(new bigint(3))
        assert(q:tostring() == "3")
        assert(r:tostring() == "1")
    end

    do
        local n = bigint.new("11355630182234424425429331560518598643298965915936825610957270519615363349759012613228119611304846673085167794661819394470107090216347491908311079792054357")
        assert(n:hex() == "D8D12A03AE2F14B16CBFDF160FF7AC97911862B3D048F18E3B95E909A08D91AAD4BA48D8A1FE4EBC555782FDE14D13085A35F6F62D57A4F86CE1FF32503A9055")
        assert(n:bitlength() == 512)
    end
end
do
    local { scheduler, socket } = require "*"

    local sched = new scheduler()
    sched:add(function()
        local l = socket.listen(30724)
        local s = l:accept()
        while data := s:recv() do
            s:send(data)
        end
    end)
    sched:add(function()
        local s = socket.connect("localhost", 30724)
        assert(s)
        s:send("Hello")
        assert(s:recv() == "Hello")
        s:close()
    end)
    sched:run()
end

print "Testing default table metatable."
do
    -- Note: This behavior may be disabled by defining the PLUTO_NO_DEFAULT_TABLE_METATABLE macro.

    local t = { "apple", "banana" }
    assert(t:contains("apple") == 1)
    assert(t:contains("banana") == 2)
    assert(t:contains("orange") == nil)
end

-- 'thread' type is given a metatable by Pluto
do
    local coro = coroutine.create(function() end)
    assert(coro:status() == "suspended")
end

print "Testing default arguments."
do
    local CONST_VAL <const> = 69
    local function f(a = 1, b = CONST_VAL, c = -2, d = +3, e = "Hello")
        return a, b, c, d, e
    end
    local a, b, c, d, e = f()
    assert(a == 1)
    assert(b == 69)
    assert(c == -2)
    assert(d == +3)
    assert(e == "Hello")

    local function tf(t = { 1, 2, 3 })
        return t
    end
    local t = tf()
    assert(#t == 3)
    assert(t[1] == 1)
    assert(t[2] == 2)
    assert(t[3] == 3)
end
do
    local function f(a = true)
        return a
    end
    assert(f() == true)
    assert(f(false) == false)
end
do
    local t = {
        function foo(a = "hello")
            return a
        end
    }
    function t:bar(a = "world")
        return a
    end
    assert(t:foo() == "hello")
    assert(t:bar() == "world")
end
do
    local f = |a = "No comment"| -> a
    assert(f() == "No comment")
    assert(f("Hello") == "Hello")
end

print "Testing walrus operator."
do
    if a := 3 then
        assert(a == 3)
    else
        error()
    end

    if b := nil then
        error()
    end

    -- Complex Context: Walrus in function body of a lambda function that is passed an argument
    local function executeFunc(f)
        f()
    end
    executeFunc(function()
        if c := 3 then
            assert(c == 3)
        else
            error()
        end
    end)
    executeFunc(|| -> do
        if c := 3 then
            assert(c == 3)
        else
            error()
        end
    end)

    -- New local for each loop iteration (if it were the same local, capturing it could result in stack corruption.)
    do
        local cnt=10
        local function next()
            cnt=cnt-1
            if cnt == 0 then return false end
            return cnt
        end

        local t = {}
        while a:=next() do
            t[#t+1] = ||->a
        end
        assert(t[1]() == 9)
        assert(t[2]() == 8)
        assert(t[3]() == 7)
        assert(t[4]() == 6)
        assert(t[5]() == 5)
        assert(t[6]() == 4)
        assert(t[7]() == 3)
        assert(t[8]() == 2)
        assert(t[9]() == 1)
    end
end

print "Testing for-as loop."
do
    local t = { "a", "b", "c" }
    local k = 1
    for t as v do
        assert(t[k] == v)
        k = k + 1
    end

    local function choose(_) return { "for", "as" } end
    for choose(function() for a as i_should_not_exist do end end) as x do
        assert(i_should_not_exist == nil, i_should_not_exist)
        assert(x == "for" or x == "as", x)
    end
end

print "Testing enums."
do
    enum begin
        UTE_ONE,
        UTE_TWO,
    end
    assert(UTE_ONE == 1)
    assert(UTE_TWO == 2)

    enum NamedTestEnum begin
        NTE_ONE,
        NTE_TWO
    end
    assert(NTE_ONE == 1)
    assert(NTE_TWO == 2)

    enum CStyleEnum begin
        CSE_INIT = 0,
        CSE_CONTINUED
    end
    assert(CSE_INIT == 0)
    assert(CSE_CONTINUED == 1)

    enum UnaryTestEnum begin
        UNAR_INVALID = -1,
        UNAR_ONE = +1
    end
    assert(UNAR_INVALID == -1)
    assert(UNAR_ONE == +1)

    enum ConstyEnum begin
        CST_VAL = 1,
        CPY_VAL = CST_VAL,
    end
    assert(CST_VAL == 1)
    assert(CPY_VAL == 1)

    enum RelativeEnum begin
        RE_MAGIC = 42,
        RE_MAGIC_PLUS_2 = RE_MAGIC + 2
    end
    assert(RE_MAGIC == 42)
    assert(RE_MAGIC_PLUS_2 == 44)
end
do
    enum class colours begin
        red,
        green,
        blue
    end
    assert(colours.red == 1)
    assert(colours.green == 2)
    assert(colours.blue == 3)
    assert(red == nil)
    assert(green == nil)
    assert(blue == nil)
end

print "Testing interpolated strings."
do
    f_string_global = "foo"
    local f_string_local = "bar"
    assert($"a{f_string_global}b{f_string_local}c" == "afoobbarc")
    assert($"{f_string_global}{f_string_local}" == "foobar")
end
do
    local t = { a = "hello" }
    assert($"{t.a} world" == "hello world")
    assert($'{t.a} world' == "hello world")

    local class Person
        name;
        age;

        function __construct(name, age)
            self.name = name
            self.age = age
        end

        function printInformation()
            return $"My name is {self.name} & my age is {self.age}."
        end
    end

    local person = new Person("John", 25)
    assert($"{person:printInformation()}" == "My name is John & my age is 25.")
end
-- @pluto_warnings: disable-next
assert($"{true ? 'true' : 'false'} is the value" == "true is the value")
do -- escaping
    local a = "world"
    assert($"hello {a}, \{}" == "hello world, {}")
    assert($"hello {a}, {1 == 1}, \{1 == 1}" == "hello world, true, {1 == 1}")
    assert($"hello {a}, {1 == 1}, \\{1 == 1}" == "hello world, true, \\true")
end

print "Testing ++ operator."
do
    -- expression
    local a = 1
    assert(++a == 2)
    assert(a == 2)
end
do
    -- statement
    local a = 1
    ++a
    assert(a == 2)

    local t = { a = 1 }
    ++t.a
    assert(t.a == 2)
end

print "Testing non-ascii variable names."
do
    local 😉 = "Hello"
    assert(😉 == "Hello")
end

print "Testing binary numerals."
do
    assert(0b11 == 3)
end

print "Testing boolean concatenation."
do
    assert(("aussie version is " .. true) == "aussie version is true")
    assert((true .. false) == "truefalse")
end

print "Testing constant expressions."
do
    assert($crypto.joaat("Pluto") == 32037948)

    -- They can be chained
    assert($crypto.joaat($crypto.sha256("hello")) == 329026960)

    -- They accept compile-time constants as argument
    local str <const> = "Pluto"
    assert($crypto.joaat(str) == 32037948)
end

print "Testing named arguments."
do
    local function getGreeting(greeting, name = "Universe")
        return greeting .. ", " .. name .. "!"
    end
    assert(getGreeting(greeting="Hello", name="World") == "Hello, World!")
    assert(getGreeting(greeting="Hello") == "Hello, Universe!")
    assert(getGreeting(name="World", greeting="Hello") == "Hello, World!")

    local function getName()
        return "Planet"
    end
    assert(getGreeting(name=getName(), greeting="Hello") == "Hello, Planet!")

    local function mixedArgs(file, mode = "r", version = 1)
        return file, mode, version
    end
    local file, mode, version = mixedArgs("Hello", version = 2)
    assert(file == "Hello")
    assert(mode == "r")
    assert(version == 2)
end

print "Testing classes."
do
    local a, b
    class BaseClass
        function __construct()
            a = true
        end
    end

    class ClassWithAnExceptionallySpecificAndLongName extends BaseClass
        function __construct()
            parent:__construct()
            b = true
        end
    end

    local inst = new ClassWithAnExceptionallySpecificAndLongName()
    assert(a == true and b == true)
end
do
    do
        class globalclass
        end
        local class localclass
        end
    end
    assert(globalclass ~= nil)
    assert(localclass == nil)
end
do
    local classexpr = class
        b = true
    end
    assert(classexpr.b == true)
end
do
    local Entity = {
        age = 1
    }

    local class Human extends Entity
    end

    local e = new Entity()
    local h = new Human()
    assert(e.age == 1)
    assert(h.age == 1)
    assert(e instanceof Entity == true)
    assert(e instanceof Human == false)
    assert(h instanceof Entity == true)
    assert(h instanceof Human == true)

    local a, b = (new Entity() instanceof Entity)
    assert(a == true)
    assert(b == nil)
    assert(new Human() instanceof Entity)
end
do
    local class Entity
        __name = "Entity"

        function __construct(name)
            self.name = name
        end
    end

    local class Human extends Entity
        __name = "Human"

        function __construct(name)
            assert(parent.__name == "Entity")
            parent:__construct(name)
        end
    end

    local john = new Human("John")
    assert(john.name == "John")
    assert(john instanceof Entity)
    assert(john instanceof Human)
end
-- Multi-level parent calls
do
    class Entity
        function __construct(name)
            self.name = name
        end
    end

    class Character extends Entity
        function __construct(name)
            parent:__construct(name)
        end
    end

    class Player extends Character
        function __construct(name)
            parent:__construct(name)
        end
    end

    local p = new Player("John")
    assert(p.name == "John")
end
-- Class overriding '__index'
do
    $define extraOffset = 10

    class Counter
        __num = 1

        function __index(key)
            if key == "num" then
                return self.__num + extraOffset
            end
            return Counter[key]
        end

        function __newindex(key, value)
            if key == "num" then
                self.__num = value - extraOffset
            end
            rawset(self, key, value)
        end
    end

    local c = new Counter()
    assert(c.num == 1 + extraOffset)
    c.num = 42
    assert(c.num == 42)
end
-- Metamethod inheritance
do
    local class Base
        function __tostring()
            return "A based object"
        end

        function __call()
            return "You called?"
        end
    end

    local class Child extends Base
        function __tostring()
            return parent:__tostring() .. ": The sequel"
        end
    end

    local b = new Base()
    local c = new Child()

    assert(tostring(b) == "A based object")
    assert(tostring(c) == "A based object: The sequel")

    assert(b() == "You called?")
    assert(c() == "You called?")
end
do
    local class ClassParsingTest
        property_no_value
        property_type_hint: string

        public property_public
        --protected property_protected
        private property_private
    end
end
-- Constructor promotion
do
    local class Point
        function __construct(public x: int, public y: int = 0)
        end
    end

    local p = new Point(3)
    assert(p.x == 3)
    assert(p.y == 0)
end
-- 'new' as a statement
do
    local ctored = false
    local method_called = false

    local class TestClass
        function __construct()
            ctored = true
        end

        function method()
            method_called = true
        end
    end

    new TestClass()
    assert(ctored == true)
    assert(method_called == false)
end
do
    local ctored = false
    local method_called = false

    local class TestClass
        function __construct()
            ctored = true
        end

        function method()
            method_called = true
        end
    end

    new TestClass():method()
    assert(ctored == true)
    assert(method_called == true)
end
do
    local namespace = {}

    class namespace.Base end
    class namespace.Derived extends namespace.Base end

    assert(new namespace.Base() instanceof namespace.Base)
    assert(new namespace.Derived() instanceof namespace.Base)
end
do
    local class Class
        private whatever = 69

        function __construct(private promoted)
        end

        function getWhatever()
            return self.whatever
        end

        function getPromoted()
            return self.promoted
        end
    end

    local inst = new Class(1337)
    assert(inst.whatever == nil)
    assert(inst.promoted == nil)
    inst.whatever = 42
    inst.promoted = 42
    assert(inst:getWhatever() == 69)
    assert(inst:getPromoted() == 1337)
end

print "Testing named varargs."
do
    local function f(...a)
        return a
    end
    local t = f("Hello", 1337)
    assert(#t == 2)
    assert(t[1] == "Hello")
    assert(t[2] == 1337)
end
do
    local f = |...args| -> table.size(args)
    assert(f() == 0)
    assert(f(1) == 1)
    assert(f(1, 2) == 2)
end

print "Testing export."
do
    local t = load [[export var = 1337

    export function func()
        return true
    end

    export class Clazz
    end
    ]] ()
    assert(t.var == 1337)
    assert(t.func() == true)
    assert(type(t.Clazz) == "table")
end
do
    local function export_in_non_main_function()
        export var = 1337

        export function func()
            return true
        end

        export class Clazz
        end
    end
    local t = export_in_non_main_function()
    assert(t.var == 1337)
    assert(t.func() == true)
    assert(type(t.Clazz) == "table")
end

print "Testing optional parentheses."
do
    assert("a.b.c":split(".")[1] == "a")

    assert({
        static function test()
            return "hello"
        end
    }.test() == "hello")
end

print "Testing table destructuring."
do
    -- Table in dedicated variable
    local t = {
        str = "hello",
        i = 1337
    }
    do
        local { str } = t
        assert(str == "hello")
    end
    do
        local { i } = t
        assert(i == 1337)
    end
    do
        local { str, i } = t
        assert(str == "hello")
        assert(i == 1337)
    end
end
do
    -- Temporary table
    local { i, str = s } = {
        i = 69,
        s = "Hello"
    }
    assert(i == 69)
    assert(s == nil)
    assert(str == "Hello")
end
do
    -- Temporary table, single field
    local { i } = {
        i = 69,
        s = "Hello"
    }
    assert(i == 69)
end
-- Array destructuring
do
    local [a, b, c] = { 1, 2, 3 }
    assert(a == 1)
    assert(b == 2)
    assert(c == 3)
end
do
    local t = { 1, 2, 3 }
    local [a, b, c] = t
    assert(a == 1)
    assert(b == 2)
    assert(c == 3)
end

print "Testing pluto_use."
do
    pluto_use class = false

    local class = { class = "class" }
    assert(class.class == "class")

    pluto_use class

    class Human end

    -- Superfluous tokens after pluto_use annotation are ignored
    assert(load[[--@pluto_use * = false   Some comment here
return true]]() == true)
end

print "Testing compile-time conditionals."
do
    local debug_bytecode = string.dump(load([[
        $define DEBUG = true
        $if DEBUG then
            print("Script running in debug mode")
        $else
            print("Script running in release mode")
        $end
    ]], ""))
    local release_bytecode = string.dump(load([[
        $define DEBUG = false
        $if DEBUG then
            print("Script running in debug mode")
        $else
            print("Script running in release mode")
        $end
    ]], ""))

    assert(debug_bytecode:find("Script running in debug mode") ~= nil)
    assert(debug_bytecode:find("Script running in release mode") == nil)
    assert(release_bytecode:find("Script running in debug mode") == nil)
    assert(release_bytecode:find("Script running in release mode") ~= nil)
end

print "Testing try/catch."
do
    -- Test case: Try does not return
    local function test(x)
        local ret
        try
            if x then
                error("error", 0)
            end
            ret = true
        catch e then
            ret = false
        end
        return ret
    end
    assert(test(false) == true)
    assert(test(true) == false)
end
do
    -- Test case: Try does return
    local function test(x)
        try
            if x then
                error("error", 0)
            end
            return true, "ok"
        catch e then
            return false, e
        end
    end
    local b, s = test(false)
    assert(b == true)
    assert(s == "ok")
    b, s = test(true)
    assert(b == false)
    assert(s == "error")
end
do
    -- Should work seamlessly with vararg functions
    local function ensure_error(callback, ...)
        try
            callback(...)
        catch e then
            return e
        end
    end
    assert(ensure_error(error, { what = "err" }).what == "err")
end
do
    -- Nil values should be returned as nil, not void.
    -- (This is most noticable with functions such as print which would say "" instead of "nil")
    local function f()
        try
            return nil
        catch e then
        end
    end
    assert(table.pack(f()).n == 1)
end
do
    -- If try block returns, catch block needs to jump over the try-return code (in case it doesn't return.)
    local function f()
        try
            return error("deez")
        catch e then
        end
        return true
    end
    assert(f() == true)
end

print "Testing compatibility."
do
    local a = "Hi"
    local t = {a}
    assert(t[1] == "Hi")
    t = {a, nil}
    assert(t[1] == "Hi")
    t = {["func"]=function(p1,p2)end}
    assert(t["func"] ~= nil)

    local myconst <const> = "consty"
    assert(myconst == "consty")

    if true then
        goto if_then_goto_test
        ::if_then_goto_test::
    end
end
do
    local function compat_names(default, parent)
        assert(default == 1)
        assert(parent == 2)
    end
    local default = 1
    local parent = 2
    compat_names(default, parent)
end
do
    local compat_parent_shorthand_syntaxes = {
        parent = true
    }
    assert(compat_parent_shorthand_syntaxes.parent == true)
end
do
    local t = { "a", "b", "c" }
    for k, v in t do
        assert(t[k] == v)
    end
end
assert(("deez" .. 69) == "deez69")
do
    local a = ""
    (function (x) a=x end)("hello")
    assert(a == "hello")
end
do
    local t = {}
    ("test string"):len()
end
do
    -- Generalized Iteration should ignore tables that have '__call' metamethods
    local called_mm, iterated = false, false
    local t = { 1 }
    setmetatable(t, {
        __call = function()
            called_mm = true
        end
    })
    for v in t do
        iterated = true
    end
    assert(called_mm)
    assert(not iterated)
end
do
    -- Possible miscompilation from compile-time concat optimization that was not caught by Lua's test suite
    assert(((true and "hello" or "goodbye") .. "world") == "helloworld")
end

print "Testing universal functions."
do
    os.setlocale("fr-FR.UTF-8")

    pcall(|| -> utonumber("", 69))
    assert(utonumber("1337") == 1337)
    assert(utonumber("1337", 16) == 0x1337)

    pcall(|| -> utostring())
    assert(utostring(1337) == "1337")

    pcall(|| -> string.uformat("%f", ""))
    assert(string.uformat("%.2f", 4.20) == "4.20")
end

print "Testing spaceship operator."
do
    assert(0 <=> 0 == 0)
    assert(0 <=> 1 == -1)
    assert(1 <=> 0 == +1)

    local function get_val()
        return 1
    end
    assert(get_val() <=> get_val() == 0)
end

print "Testing implicit/explicit global creation."
do
    assert_warn [[pluto_use global; a = 1]]
    assert_warn [[pluto_use global; function a() end]]
    assert_warn [[pluto_use global; class a end]]
    assert_no_warn [[pluto_use global; local a; a = 1]]
    assert_no_warn [[pluto_use global; local a; do a = 1 end]]

    -- explicit globals
    assert_no_warn [[pluto_use global; global a = 1]]
    assert_no_warn [[pluto_use global; global function a() end]]
    assert_no_warn [[pluto_use global; global class a end]]

    -- predefine globals
    assert_no_warn [[pluto_use global; global a; a = 1]]
    assert_no_warn [[pluto_use global; global a, b; a = 1; b = 2]]
end

print "Testing modified require semantics."
do
    local currentdir = io.absolute(io.currentdir())
    if not io.currentdir():endswith("testes") then
        io.currentdir("testes")
    end
    package.preload["example_module"] = || -> "Test Value"
    assert(select(2, require("example_module")):contains("example_module.pluto"))
    assert(select(1, require("pluto:example_module")) == "Test Value")
    package.preload["example_module"] = nil
    assert(select(2, pcall(|| -> require("a"))):contains("module 'a' not found"))
    assert(select(2, pcall(|| -> require("pluto:a"))):contains("is not a valid pluto library"))
    io.currentdir(currentdir)
    -- check cwd if this fails.
end
