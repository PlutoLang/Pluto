## Building

The fastest way to compile Pluto is using the PHP build scripts, e.g. with Clang:
```
php scripts/compile.php clang
php scripts/link_pluto.php clang
php scripts/link_plutoc.php clang
```

But it can also be compiled via Make with GCC, e.g. multithreaded compile on Linux:
```
make -j PLAT=linux
```

In both cases, the binaries `pluto` and `plutoc` will be put in the `src/` folder.

## Testing

After building Pluto, you can run the test suite like so:
```
src/pluto testes/_driver.pluto
```

# Repository Guidelines - Generated by https://clara.md/ from Faros AI

## Scope & Layout
- Core runtime and compiler sources live in `src/`, reflecting Lua’s paired `.cpp`/`.h` structure (e.g., `lapi.cpp` with `lapi.h`).
- Generated jump tables reside in `src/*.sun`; regenerate rather than editing them by hand.
- Third-party code is isolated under `src/vendor/`; build helpers live in `scripts/`, while project files (`Makefile`, `Pluto.sln`, etc.) sit at the repo root.
- Functional tests and fixtures belong in `testes/`. Add new cases beside `_driver.pluto` so the harness autodiscovers them.

## Coding Standards
- Two-space indentation, same-line braces for control structures, no tabs. Filenames and functions stay lowercase with underscores/digits; reserve PascalCase for vendor classes.
- Macros use the `PLUTO_*` family; keep headers guarded using the Lua-style prefix.
- Preserve existing style/whitespace and update subsystem comment headers when changing GC/VM-sensitive files.

## Testing Expectations
- Run `src/pluto testes/_driver.pluto` to exercise interpreter and compiler paths together.
- Name new tests descriptively (e.g., `testes/json/encode_numbers.pluto`), keep them deterministic, and use protected calls for negative scenarios.
- Performance-sensitive changes should compare `testes/bench/*.pluto` timings before and after the patch.

## Commit & PR Practices
- Use short, imperative commit subjects (`Fix GC debt accounting`, `[Soup] Update request fallback`). Each commit must compile and pass tests.
- Pull requests should include a concise summary, reproduction steps for bug fixes, and a checklist of commands executed. Reference related issues and attach logs or screenshots when behavior changes.

## Execution Principles
- Identify the correct owner and layer before editing (`llex.*`/`lparser.*` for lexer/parser, `lcode.*` for codegen, `lvm.cpp` for VM, library helpers in `l*.cpp`, vendor work in `src/vendor/*`, tests in `testes/`).
- Keep scope minimal: only the files and contiguous hunks required. Avoid drive-by refactors, doc/test edits, or vendor touches unless acceptance demands them.
- Maintain header/implementation parity and update build wiring (`Makefile`, Visual Studio projects/filters, `scripts/common.php`) whenever symbols or files change.
- Respect platform guards in `luaconf.h` (Android/WASM, etc.) and mirror the guards in build/project files when adding conditional behavior.
- Produce valid unified diffs (`---/+++` with `@@` markers) without logs, preserving surrounding context and existing whitespace.
- Match acceptance-specified diagnostics exactly (punctuation, casing, location info).
- Use canonical, case-correct paths; never create renamed or `_modified` files to host changes.
- Plan required hunks ahead of time using acceptance/top-path hints and confirm every expected location is addressed.

## Owner Map (Quick Reference)
- HTTP client behaviour: `src/lhttplib.cpp`, with cross-boundary wiring in `src/vendor/Soup/soup/HttpRequestTask.{hpp,cpp}` as needed.
- OS/time/filesystem APIs: `src/loslib.cpp`.
- Table APIs vs engine: user entry points in `src/ltablib.cpp`; data-structure logic in `src/ltable.cpp`/`src/ltable.h`.
- Lexer/parser/config: tokens in `src/llex.*`, grammar/state in `src/lparser.*`, toggles in `src/luaconf.h`.
- Runtime execution: `src/lvm.cpp`; bytecode generation in `src/lcode.*`.

## Frequent Failure Patterns
- Wrong owner/path: edits landed in neighbors (e.g., `liolib.cpp`, docs) instead of the intended module. Always retarget to the precise file.
- Missed companion hunks: partial updates within a file or across `.cpp`/`.h` pairs; audit the entire region to keep interfaces aligned.
- Header/implementation drift between parser ↔ lexer or table lib ↔ engine; synchronize both sides plus headers.
- Extra/unrelated hunks from whitespace/comment tweaks; keep edits contiguous and revert incidental noise.
- Diff formatting issues (`no diff markers found; wrote raw output`); regenerate patches before submission.
- Diagnostics mismatches where error text failed to match gold punctuation/case.
- Cross-boundary coordination gaps (parser ↔ lexer, core ↔ vendor, script ↔ project files) leading to build/link failures.
- Top-path coverage misses: acceptance lists multiple prefixes—treat them as mandatory rather than stopping after the first file.
- Case-sensitive path mistakes or placeholder files; use the canonical filenames and never introduce stubs just to house edits.
- Tooling warnings (e.g., `set: pipefill`) must be resolved before resubmitting so hunks aren’t dropped.

## Pre-Submit Checklist
- Correct owner/prefix identified; only intended files are touched.
- Patch is a clean unified diff with the minimal necessary hunks.
- Headers, build files, and scripts updated to reflect code changes.
- Build succeeds and targeted tests run for the affected area.
- Vendor/test/doc trees remain untouched unless explicitly part of the task.
- Original style and context preserved; no formatting-only churn.
- Multi-area work (parser + lexer + headers + config, etc.) stays in lockstep.
- 